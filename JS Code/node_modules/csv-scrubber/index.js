#!/usr/bin/env node

'use strict';
const csvParse = require('csv-parse');
const csvStringify = require('csv-stringify');
const streamTransform = require('stream-transform');
const fs = require('fs');
const path = require('path');
const loglove = require('loglove');
const devnull = require('dev-null');

class CsvScrubber {

  // splits = [] array of split objects
  // we will add name access to splits so you can access the 'account'
  // split as split.account.
  // split = an object like this.
  // { name:'account',
  //   header: ['fielda', 'fieldb'],
  //   outstream: optional filepath or stream defaults to {name}.csv }
  // TODO maybe allow split config to be either array like above or object like
  // { my_split_name: { header: [], outstream: someStream },
  //   another_split: { header: [], outstream: anotherStr } }
  constructor(conf) {
    conf = conf || {};
    this.currentRow = 0;
    this._initLogging(conf);
    this._initSplits(conf);
    this.instream = conf.instream || process.stdin;
    this._initOutstream(conf);
    this.mware = require('mware')();
    this.stringify = csvStringify();
  }

  _initLogging(conf) {
    const defaultOpts = {
      config: {
        WARN: '**'
      },
      format: (string, levelName) => {
        return `${levelName} [line ${this.currentRow}]: ${string}\n`;
      }
    };
    if (!conf.logOptions) {
      if (conf.outputDir) {
        defaultOpts.out = fs.createWriteStream(path.join(conf.outputDir, 'scrub.log'));
      } else {
        defaultOpts.out = fs.createWriteStream('scrub.log');
      }
    }
    this.log = loglove(conf.logOptions || defaultOpts).log();
  }

  _initSplits(conf) {
    this.log.debug('_initSplits');
    this.splits = conf.splits || [];
    this.splits.forEach((sp) => {
      this.splits[sp.name] = sp;
      sp.blankRow = [];
      for (let junk of sp.header) {
        sp.blankRow.push('');
      }
      // would you ever want a split with no output?
      // should i make it same as main output stream where if you pass falsey
      // value we output nothing. does that even make sense?
      if (!sp.outstream) {
        this._addConfOutputDir(conf.outputDir, `${sp.name}.csv`, sp);
        // if (conf.outputDir) {
        //   sp.outstream = fs.createWriteStream(path.join(conf.outputDir, `${sp.name}.csv`));
        // } else {
        //   sp.outstream = fs.createWriteStream(`${sp.name}.csv`);
        // }
      } else if (typeof sp.outstream === 'string' || sp.outstream instanceof String) {
        this._addConfOutputDir(conf.outputDir, sp.outstream, sp);
        // if (conf.outputDir) {
        //   sp.outstream = fs.createWriteStream(path.join(conf.outputDir, sp.outstream));
        // } else {
        //   sp.outstream = fs.createWriteStream(sp.outstream);
        // }
      }
    });
  }

  _addConfOutputDir(outputDir, outfile, obj) {
    if (outputDir) {
      obj.outstream = fs.createWriteStream(path.join(outputDir, outfile));
    } else {
      obj.outstream = fs.createWriteStream(outfile);
    }
  }

  // If you specifically pass a falsey value we use devnull.
  // If you specifically pass a stream or a string file name we use it.
  // If you pass nothing we use stdout.
  _initOutstream(conf) {
    this.log.debug('_initOutstream');
    if ('outstream' in conf) {
      if (conf.outstream) {
        this._outStringOrStream(conf);
      } else {
        // this.outstream = fs.createWriteStream('/dev/null');
        this.outstream = devnull(); // works on windows.
      }
    } else {
      this.outstream = process.stdout;
    }
  }

  _outStringOrStream(conf) {
    this.log.debug('_outStringOrStream');
    if (typeof conf.outstream === 'string' || conf.outstream instanceof String) {
      this._addConfOutputDir(conf.outputDir, conf.outstream, this);
      // if (conf.outputDir) {
      //   this.outstream = fs.createWriteStream(path.join(conf.outputDir, conf.outstream));
      // } else {
      //   this.outstream = fs.createWriteStream(conf.outstream);
      // }
    } else {
      this.outstream = conf.outstream;
    }
  }

  // Output the actual split array to output stream.
  _outputSplit(record, split, cb) {
    this.log.debug('_outputSplit');
    // You can delete the split for a given row by making it null or zero length.
    if (record[split.name] && record[split.name].length > 0) {
      split.outstream.write(this.stringify.stringify(record[split.name]) + '\n', cb);
    } else {
      cb(null);
    }
  }

  // Output all the splits for a given record.
  _outputRecordSplits(record, cb) {
    this.log.debug('_outputRecordSplits');
    let l = this.splits.length;
    if (l === 0) {
      cb(null);
      return;
    }
    let i = 0;
    let errors = [];
    let cbb = (error) => {
      this.log.debug(`_outputRecordSplits i: ${i} l: ${l} errors: ${errors} `);
      if (error) {
        errors.push(error);
      }
      i++;
      if (i === l) {
        cb(errors.length === 0 ? null : errors);
      }
    };
    this.splits.forEach((sp) => {
      this._outputSplit(record, sp, cbb);
    });
  }

  // Output splits for all records in this row.
  _outputRowSplits(records, cb) {
    this.log.debug('_outputRowSplits');
    let l = records.length;
    if (l === 0) {
      cb(null);
      return;
    }
    let i = 0;
    let errors = [];
    let cbb = (error) => {
      this.log.debug(`_outputRowSplits i: ${i} l: ${l} errors: ${errors} `);
      if (error) {
        errors.push(error);
      }
      i++;
      if (i === l) {
        cb(errors.length === 0 ? null : errors);
      }
    };
    records.forEach((record) => {
      this._outputRecordSplits(record, cbb);
    });
  }

  // For each split add the header row and add a blank row for each non-header
  // row. Blank row is important so you don't have to make sure to populate
  // every column. You get a row with each column having a blank value.
  _addSplits(record) {
    this.log.debug('_addSplits');
    this.splits.forEach((split) => {
      if (this.currentRow === 1) {
        record[split.name] = split.header.slice(0);
      } else {
        record[split.name] = split.blankRow.slice(0);
      }
    });
  }

  // Here's where we call all the middleware for each input row.
  _scrub(record, cb) {
    this.log.debug('_scrub');
    this.currentRow++;
    this._addSplits(record);
    let records = [record];
    // middleware for the win.
    this.mware.run(records, (error) => {
      if (error) {
        records.unshift(error);
        cb.apply(null, records);
      } else {
        this._outputRowSplits(records, (error) => {
          records.unshift(error);
          cb.apply(null, records);
        });
      }
    });
  }

  // Clone record making sure splits are in tact and make sure column name
  // access is intact if you are using the addNameAccess middleware.
  clone(record) {
    let c = record.slice(0);
    this._addSplits(c);
    if (this.nameIndex) {
      this.addNameAccess([c]);
    }
    return c;
  }

  // Middleware
  //
  // Basically make column names SQL friendly.
  // Trim, lower case, convert non alpha numeric to underscore.
  // Merge multiple underscores into one.
  // Warn on duplicate column name.
  normalizeHeader(records, cb) {
    let cols = {};
    for (let i = 0, l = records[0].length; i < l; i++) {
      if (records[0][i]) {
        records[0][i] = records[0][i].trim().toLowerCase().replace(/[^a-z0-9_]+/g, '_');
        if (records[0][i] in cols) {
          this.log.warn(`duplicate column name: ${records[0][i]}`);
        }
        cols[records[0][i]] = true;
      }
    }
    cb(null);
  }

  // Helper method for addNameAccess middleware.
  addGetSet(rec, nameIndex) {
    for (let name in nameIndex) {
      Object.defineProperty(rec, name, {
        /* jshint loopfunc: true */
        get: () => {
          return rec[nameIndex[name]];
        },
        set: (value) => {
          rec[nameIndex[name]] = value;
        }
      });
    }
  }

  // Middleware
  //
  // Add field (column) name access to records so you don't have to count all
  // the time. You can say record.phone_number instead of record[34] or
  // record.my_split.phone_number instead of record.my_split[7].
  addNameAccess(records, cb) {
    this.log.debug('addNameAccess');
    /* jshint validthis: true */
    /* jshint loopfunc: true */
    if (this.currentRow === 1) {
      this.nameIndex = {};
      for (let i = 0, l = records[0].length; i < l; i++) {
        // It's an error to have header column with no value.
        // if (records[0][i]) {
        this.nameIndex[records[0][i]] = i;
        // }
      }
      this.splits.forEach((sp) => {
        sp.nameIndex = {};
        for (let i = 0, l = sp.header.length; i < l; i++) {
          // It's an error to have header column with no value.
          // if (sp.header[i]) {
          sp.nameIndex[sp.header[i]] = i;
          // }
        }
      });
    } else {
      for (let rec of records) {
        this.addGetSet(rec, this.nameIndex);
        // rec.get = (name) => {
        //   return rec[this.nameIndex[name]];
        // };
        // rec.set = (name, value) => {
        //   rec[this.nameIndex[name]] = value;
        // };
        this.splits.forEach((sp) => {
          this.addGetSet(rec[sp.name], sp.nameIndex);
          // rec[sp.name].get = (name) => {
          //   return rec[sp.name][sp.nameIndex[name]];
          // };
          // rec[sp.name].set = (name, value) => {
          //   rec[sp.name][sp.nameIndex[name]] = value;
          // };
        });
      }
    }
    if (cb) {
      cb(null);
    }
  }

  // Add middleware for header row only.
  useHeader(middleware) {
    let f = (records, cb) => {
      if (this.currentRow === 1) {
        middleware(records, cb);
      } else {
        cb(null);
      }
    };
    this.mware(f);
  }

  // Add middleware for all rows.
  useAllRows(middleware) {
    this.mware(middleware);
  }

  // Add middleware for non-header rows only.
  use(middleware) {
    let f = (records, cb) => {
      if (this.currentRow > 1) {
        middleware(records, cb);
      } else {
        cb(null);
      }
    };
    this.mware(f);
  }

  // This is the main method. Scrub away!
  scrub(cb) {
    this.log.debug('scrub');
    this.instream
      .pipe(csvParse())
      .pipe(streamTransform(this._scrub.bind(this)))
      .pipe(csvStringify())
      .pipe(this.outstream)
      .on('error', (error) => {
        cb(error);
      })
      .on('finish', () => {
        cb(null);
      });
  }
}

exports = module.exports = (conf) => {
  return new CsvScrubber(conf);
};

if (require.main === module) {
  //
  // Example
  //
  // ./index.js < spottest/example.csv
  //
  let growOld = function(records, cb) {
    this.log.debug('growOld');
    for (let i = 0, l = records[0].length; i < l; i++) {
      records[i][1] = parseInt(records[i][1]) + 23;
    }
    cb(null);
  };
  let skipTheRestOfTheMiddleware = function(records, cb) {
    // true second argument means don't process any middleware.
    cb(null, true);
  };

  let conf = {
    splits: [{
      name: 'frank',
      header: ['height', 'weight']
    }],
    instream: fs.createReadStream('spottest/example.csv'),
    outputDir: 'spottest'
  };

  const scrbr = new CsvScrubber(conf);

  scrbr.useHeader(scrbr.normalizeHeader);
  // scrbr.use(skipTheRestOfTheMiddleware);
  scrbr.useAllRows(scrbr.addNameAccess.bind(scrbr));
  scrbr.use(function(records, cb) {
    records[0].frank.height = '5.11';
    records[0].frank.weight = 243;
    let cl = scrbr.clone(records[0]);
    records.push(cl);
    cl.name = `Bossy Betty & the Flecktones "!@#"`;
    this.log.info('cl.name: ' + cl.name);
    cl.age = 19;
    cl.frank.height = `7' 11"`;
    cl.frank.weight = 131;
    cb(null);
  }.bind(scrbr));
  scrbr.use(growOld.bind(scrbr));

  scrbr.scrub((error) => {
    if (error) throw error;
  });
}